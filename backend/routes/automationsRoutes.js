// backend/routes/automationsRoutes.js

require('dotenv').config();
const express     = require('express');
const requireAuth = require('../middleware/requireAuth');
const Automation  = require('../models/Automation');
const User        = require('../models/User');
const { createGmailLabel } = require('../controllers/gmail');
const OpenAI      = require('openai');

const router = express.Router();

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// System prompt describing the automation schema
const SYSTEM_PROMPT = `
You are given a JSON schema for "automations".
Each automation must have:
- label: string
- description: string
- conditions: {
    subjectContains: string[],
    bodyContains: string[]
  }
- actions: {
    markImportant: boolean,
    autoDraft: boolean,
    autoDraftInstructions: string (custom instructions for drafting),
    autoReply: boolean,
    autoReplyInstructions: string (custom instructions for replying),
    autoForward: boolean,
    autoForwardInstructions: string (custom instructions for forwarding),
    forwardTo: string (email address to forward to),
    textNotification: boolean,
    phoneNumber: string (phone number for notifications)
  }

When processing natural language instructions:
1. Extract specific action requirements (e.g., "mark as important", "draft a reply", "forward to manager@company.com")
2. Include relevant custom instructions for drafting, replying, or forwarding
3. Extract email addresses for forwarding and phone numbers for notifications
4. Set appropriate boolean flags based on mentioned actions

Examples:
- "Mark all invoices as important and draft a professional thank you reply" → markImportant: true, autoDraft: true, autoDraftInstructions: "professional thank you reply"
- "Forward urgent emails to manager@company.com and send me a text" → autoForward: true, forwardTo: "manager@company.com", textNotification: true

Return an array of automations matching the user's instructions in valid JSON only.
Do NOT include any explanatory text.
`;

/**
 * POST /api/automations/rebuild
 * Body: { instructions: string }
 * Replaces all existing automations for the user with those generated by the LLM.
 */
router.post('/rebuild', requireAuth, async (req, res) => {
  const { instructions } = req.body;
  if (!instructions || typeof instructions !== 'string') {
    return res.status(400).json({ error: 'instructions must be a nonempty string' });
  }

  try {
    // Find user record
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    // Generate automations via OpenAI
    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        { role: 'system', content: SYSTEM_PROMPT },
        { role: 'user',   content: instructions }
      ],
      temperature: 0.2,
      max_tokens: 1000
    });

    const text = completion.choices[0].message.content.trim();
    let parsed;
    try {
      parsed = JSON.parse(text);
      if (!Array.isArray(parsed)) throw new Error('Expected JSON array');
    } catch (err) {
      console.error('Invalid JSON from OpenAI:', text);
      return res.status(502).json({ 
        error: 'AI returned invalid JSON',
        details: 'Please try rephrasing your instructions or contact support.'
      });
    }

    // Validate and normalize automation objects
    const validatedAutomations = parsed.map((rule, index) => {
      if (!rule.label) {
        throw new Error(`Automation ${index + 1} is missing a label`);
      }

      // Ensure actions object exists and has proper structure
      const actions = {
        markImportant: false,
        autoDraft: false,
        autoDraftInstructions: '',
        autoReply: false,
        autoReplyInstructions: '',
        autoForward: false,
        autoForwardInstructions: '',
        forwardTo: '',
        textNotification: false,
        phoneNumber: '',
        ...rule.actions
      };

      // Extract email addresses from instructions if forwardTo is not set
      if (actions.autoForward && !actions.forwardTo) {
        const emailMatch = instructions.match(/[\w.-]+@[\w.-]+\.\w+/);
        if (emailMatch) {
          actions.forwardTo = emailMatch[0];
        }
      }

      // Extract phone numbers from instructions if phoneNumber is not set
      if (actions.textNotification && !actions.phoneNumber) {
        const phoneMatch = instructions.match(/\+?[\d\s\-\(\)]{10,}/);
        if (phoneMatch) {
          actions.phoneNumber = phoneMatch[0].replace(/\s+/g, '');
        }
      }

      return {
        userId: user._id,
        label: rule.label.trim(),
        description: (rule.description || '').trim(),
        conditions: {
          subjectContains: Array.isArray(rule.conditions?.subjectContains) 
            ? rule.conditions.subjectContains.filter(Boolean) 
            : [],
          bodyContains: Array.isArray(rule.conditions?.bodyContains) 
            ? rule.conditions.bodyContains.filter(Boolean) 
            : [],
        },
        actions,
        isActive: true
      };
    });

    // Soft delete old automations by setting isActive to false
    await Automation.updateMany(
      { userId: user._id },
      { isActive: false, updatedAt: new Date() }
    );

    console.log(`Soft deleted existing automations for user ${user.email}`);

    // Insert and return
    const created = await Automation.insertMany(validatedAutomations);
    
    console.log(`Successfully created ${created.length} automations from natural language instructions`);
    
    res.json({
      message: `Successfully created ${created.length} automation(s)`,
      automations: created
    });

  } catch (err) {
    console.error('Error rebuilding automations:', err);
    res.status(500).json({ 
      error: 'Failed to rebuild automations',
      details: err.message 
    });
  }
});

/**
 * GET /api/automations
 * Returns all active automations for the authenticated user.
 */
router.get('/', requireAuth, async (req, res) => {
  try {
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const automations = await Automation
      .find({ userId: user._id, isActive: true })
      .sort({ updatedAt: -1 });

    res.json(automations);

  } catch (err) {
    console.error('Error fetching automations:', err);
    res.status(500).json({ error: 'Failed to fetch automations' });
  }
});

/**
 * GET /api/automations/all
 * Returns all automations (including inactive) for debugging purposes.
 */
router.get('/all', requireAuth, async (req, res) => {
  try {
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const automations = await Automation
      .find({ userId: user._id })
      .sort({ updatedAt: -1 });

    res.json(automations);

  } catch (err) {
    console.error('Error fetching all automations:', err);
    res.status(500).json({ error: 'Failed to fetch all automations' });
  }
});

/**
 * POST /api/automations
 * Creates a single new automation.
 */
router.post('/', requireAuth, async (req, res) => {
  try {
    const { label, description, conditions, actions } = req.body;
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const automation = new Automation({
      userId:      user._id,
      label,
      description,
      conditions,
      actions:     actions || {},
      isActive:    true
    });

    await automation.save();

    // Create Gmail label
    try {
      await createGmailLabel(user, label);
      console.log(`Gmail label "${label}" created.`);
    } catch (e) {
      console.error(`Failed to create Gmail label "${label}":`, e.message);
    }

    res.status(201).json(automation);

  } catch (err) {
    console.error('Error creating automation:', err);
    res.status(400).json({ error: err.message || 'Failed to create automation' });
  }
});

/**
 * PATCH /api/automations/:id
 * Updates an existing automation.
 */
router.patch('/:id', requireAuth, async (req, res) => {
  try {
    const { label, description, conditions, actions } = req.body;
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const updated = await Automation.findOneAndUpdate(
      { _id: req.params.id, userId: user._id },
      {
        ...(label       && { label }),
        ...(description && { description }),
        ...(conditions  && { conditions }),
        ...(actions     && { actions }),
        updatedAt: new Date()
      },
      { new: true, runValidators: true }
    );

    if (!updated) return res.status(404).json({ error: 'Automation not found' });
    res.json(updated);

  } catch (err) {
    console.error('Error updating automation:', err);
    res.status(400).json({ error: err.message || 'Failed to update automation' });
  }
});

/**
 * DELETE /api/automations/:id
 * Soft deletes a single automation by setting isActive to false.
 */
router.delete('/:id', requireAuth, async (req, res) => {
  try {
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const updated = await Automation.findOneAndUpdate(
      {
        _id: req.params.id,
        userId: user._id
      },
      {
        isActive: false,
        updatedAt: new Date()
      },
      { new: true }
    );

    if (!updated) return res.status(404).json({ error: 'Automation not found' });
    
    console.log(`Soft deleted automation "${updated.label}" for user ${user.email}`);
    res.json({ message: 'Automation deleted successfully' });

  } catch (err) {
    console.error('Error deleting automation:', err);
    res.status(500).json({ error: 'Failed to delete automation' });
  }
});

/**
 * DELETE /api/automations/:id/permanent
 * Permanently deletes a single automation from the database.
 */
router.delete('/:id/permanent', requireAuth, async (req, res) => {
  try {
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const deleted = await Automation.findOneAndDelete({
      _id: req.params.id,
      userId: user._id
    });

    if (!deleted) return res.status(404).json({ error: 'Automation not found' });
    
    console.log(`Permanently deleted automation "${deleted.label}" for user ${user.email}`);
    res.json({ message: 'Automation permanently deleted' });

  } catch (err) {
    console.error('Error permanently deleting automation:', err);
    res.status(500).json({ error: 'Failed to permanently delete automation' });
  }
});

module.exports = router;