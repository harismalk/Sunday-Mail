// backend/routes/automationsRoutes.js

require('dotenv').config();
const express     = require('express');
const requireAuth = require('../middleware/requireAuth');
const Automation  = require('../models/Automation');
const User        = require('../models/User');
const { createGmailLabel } = require('../controllers/gmail');
const OpenAI      = require('openai');

const router = express.Router();

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// System prompt describing the automation schema
const SYSTEM_PROMPT = `
You are given a JSON schema for "automations".
Each automation must have:
- label: string
- description: string
- conditions: {
    subjectContains: string[],
    bodyContains: string[]
  }
- actions: {
    markImportant: boolean,
    autoDraft: boolean,
    autoDraftInstructions: string (custom instructions for drafting),
    autoReply: boolean,
    autoReplyInstructions: string (custom instructions for replying),
    autoForward: boolean,
    autoForwardInstructions: string (custom instructions for forwarding),
    forwardTo: string (email address to forward to),
    textNotification: boolean,
    phoneNumber: string (phone number for notifications)
  }

When processing natural language instructions:
1. Extract specific action requirements (e.g., "mark as important", "draft a reply", "forward to manager@company.com")
2. Include relevant custom instructions for drafting, replying, or forwarding
3. Extract email addresses for forwarding and phone numbers for notifications
4. Set appropriate boolean flags based on mentioned actions

Examples:
- "Mark all invoices as important and draft a professional thank you reply" → markImportant: true, autoDraft: true, autoDraftInstructions: "professional thank you reply"
- "Forward urgent emails to manager@company.com and send me a text" → autoForward: true, forwardTo: "manager@company.com", textNotification: true

Return an array of automations matching the user's instructions in valid JSON only.
Do NOT include any explanatory text.
`;

/**
 * POST /api/automations/rebuild
 * Body: { instructions: string }
 * Replaces all existing automations for the user with those generated by the LLM.
 */
router.post('/rebuild', requireAuth, async (req, res) => {
  const { instructions } = req.body;
  if (!instructions || typeof instructions !== 'string') {
    return res.status(400).json({ error: 'instructions must be a nonempty string' });
  }

  try {
    // Find user record
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    // Generate automations via OpenAI
    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        { role: 'system', content: SYSTEM_PROMPT },
        { role: 'user',   content: instructions }
      ],
      temperature: 0.2,
      max_tokens: 800
    });

    const text = completion.choices[0].message.content.trim();
    let parsed;
    try {
      parsed = JSON.parse(text);
      if (!Array.isArray(parsed)) throw new Error('Expected JSON array');
    } catch (err) {
      console.error('Invalid JSON from OpenAI:', text);
      return res.status(502).json({ error: 'AI returned invalid JSON' });
    }

    // Delete old automations
    await Automation.deleteMany({ userId: user._id });

    // Build new automation documents
    const docs = parsed.map(rule => ({
      userId:      user._id,
      label:       rule.label,
      description: rule.description || '',
      conditions:  rule.conditions || { subjectContains: [], bodyContains: [] },
      actions:     rule.actions || {},
      isActive:    true
    }));

    // Insert and return
    const created = await Automation.insertMany(docs);
    res.json(created);

  } catch (err) {
    console.error('Error rebuilding automations:', err);
    res.status(500).json({ error: 'Failed to rebuild automations' });
  }
});

/**
 * GET /api/automations
 * Returns all automations for the authenticated user.
 */
router.get('/', requireAuth, async (req, res) => {
  try {
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const automations = await Automation
      .find({ userId: user._id })
      .sort({ updatedAt: -1 });

    res.json(automations);

  } catch (err) {
    console.error('Error fetching automations:', err);
    res.status(500).json({ error: 'Failed to fetch automations' });
  }
});

/**
 * POST /api/automations
 * Creates a single new automation.
 */
router.post('/', requireAuth, async (req, res) => {
  try {
    const { label, description, conditions, actions } = req.body;
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const automation = new Automation({
      userId:      user._id,
      label,
      description,
      conditions,
      actions:     actions || {},
      isActive:    true
    });

    await automation.save();

    // Create Gmail label
    try {
      await createGmailLabel(user, label);
      console.log(`Gmail label "${label}" created.`);
    } catch (e) {
      console.error(`Failed to create Gmail label "${label}":`, e.message);
    }

    res.status(201).json(automation);

  } catch (err) {
    console.error('Error creating automation:', err);
    res.status(400).json({ error: err.message || 'Failed to create automation' });
  }
});

/**
 * PATCH /api/automations/:id
 * Updates an existing automation.
 */
router.patch('/:id', requireAuth, async (req, res) => {
  try {
    const { label, description, conditions, actions } = req.body;
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const updated = await Automation.findOneAndUpdate(
      { _id: req.params.id, userId: user._id },
      {
        ...(label       && { label }),
        ...(description && { description }),
        ...(conditions  && { conditions }),
        ...(actions     && { actions }),
        updatedAt: new Date()
      },
      { new: true, runValidators: true }
    );

    if (!updated) return res.status(404).json({ error: 'Automation not found' });
    res.json(updated);

  } catch (err) {
    console.error('Error updating automation:', err);
    res.status(400).json({ error: err.message || 'Failed to update automation' });
  }
});

/**
 * DELETE /api/automations/:id
 * Deletes a single automation.
 */
router.delete('/:id', requireAuth, async (req, res) => {
  try {
    const email = req.user.profile.emails[0].value;
    const user  = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });

    const deleted = await Automation.findOneAndDelete({
      _id: req.params.id,
      userId: user._id
    });

    if (!deleted) return res.status(404).json({ error: 'Automation not found' });
    res.json({ message: 'Automation deleted successfully' });

  } catch (err) {
    console.error('Error deleting automation:', err);
    res.status(500).json({ error: 'Failed to delete automation' });
  }
});

module.exports = router;